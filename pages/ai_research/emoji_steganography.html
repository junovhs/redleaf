<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Emoji Steganography Encoder/Decoder</title>
  <style>
    body {
      font-family: sans-serif;
      background: #f5f5f5;
      margin: 0;
      padding: 20px;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      background: #ffffff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    
    .section {
      margin-bottom: 30px;
    }
    
    textarea,
    input[type="text"] {
      width: 100%;
      padding: 10px;
      font-size: 1em;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
      margin-bottom: 10px;
    }
    
    button {
      background-color: #007bff;
      color: white;
      padding: 10px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1em;
    }
    
    button:hover {
      background-color: #0056b3;
    }
    
    .result {
      padding: 10px;
      background: #eee;
      border-radius: 4px;
      min-height: 20px;
      word-wrap: break-word;
      font-size: 1.2em;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Emoji Steganography Encoder/Decoder</h1>
    
    <div class="section">
      <h2>Encode Text</h2>
      <textarea id="inputText" rows="5" placeholder="Enter text to encode here..."></textarea>
      <button id="encodeBtn">Encode to Emoji</button>
      <p>Encoded Emoji:</p>
      <div id="encodedEmoji" class="result"></div>
    </div>
    
    <div class="section">
      <h2>Decode Emoji</h2>
      <input type="text" id="encodedInput" placeholder="Paste encoded emoji here..." />
      <button id="decodeBtn">Decode Text</button>
      <p>Decoded Text:</p>
      <div id="decodedText" class="result"></div>
    </div>
  </div>

  <script>
    // This script implements the Emoji Steganography Encoder/Decoder using invisible zero-width characters.
    // The cover emoji is set to "ðŸ˜Š" and the hidden data is encoded using three invisible characters:
    //   U+200B (ZERO WIDTH SPACE) represents binary "0"
    //   U+200C (ZERO WIDTH NON-JOINER) represents binary "1"
    //   U+200D (ZERO WIDTH JOINER) is used as a delimiter between encoded Unicode code points.
    //
    // Each Unicode code point from the input text is converted to a binary string padded to 21 bits
    // (which supports all valid Unicode code points up to U+10FFFF). Each bit is mapped to its
    // corresponding invisible character. The blocks for each character are then joined with the delimiter,
    // and finally prefixed with the cover emoji so that the encoded result appears as a normal emoji.
    
    const coverEmoji = "ðŸ˜Š";
    const ZERO_WIDTH_SPACE = "\u200B";      // Represents binary "0"
    const ZERO_WIDTH_NON_JOINER = "\u200C";   // Represents binary "1"
    const ZERO_WIDTH_JOINER = "\u200D";       // Delimiter between characters
    const BIT_LENGTH = 21; // Fixed bit-length per Unicode code point
    
    /**
     * Encodes the given plain text into an emoji with hidden data.
     * @param {string} plainText - The text to be encoded.
     * @returns {string} A string beginning with the cover emoji followed by invisible data.
     */
    function encodeText(plainText) {
      if (!plainText) {
        return coverEmoji;
      }
      const encodedBlocks = [];
      // Use for...of to correctly iterate over Unicode code points.
      for (const char of plainText) {
        const codePoint = char.codePointAt(0);
        // Convert the code point to a binary string, padded to BIT_LENGTH bits.
        const binaryStr = codePoint.toString(2).padStart(BIT_LENGTH, "0");
        // Map each binary digit to its corresponding invisible character.
        const invisibleBlock = [...binaryStr]
          .map((bit) => (bit === "0" ? ZERO_WIDTH_SPACE : ZERO_WIDTH_NON_JOINER))
          .join("");
        encodedBlocks.push(invisibleBlock);
      }
      // Join blocks with the zero-width joiner as a delimiter.
      const invisibleData = encodedBlocks.join(ZERO_WIDTH_JOINER);
      return coverEmoji + invisibleData;
    }
    
    /**
     * Decodes a hidden message from an emoji that was encoded with encodeText.
     * @param {string} encodedEmojiStr - The emoji string with hidden data.
     * @returns {string} The decoded plain text.
     */
    function decodeText(encodedEmojiStr) {
      if (!encodedEmojiStr.startsWith(coverEmoji)) {
        alert("Encoded string does not start with the expected cover emoji.");
        return "";
      }
      // Remove the cover emoji from the beginning.
      const hiddenData = encodedEmojiStr.slice(coverEmoji.length);
      if (!hiddenData) {
        return "";
      }
      // Split the hidden data into blocks using the delimiter.
      const blocks = hiddenData.split(ZERO_WIDTH_JOINER);
      let decodedText = "";
      for (const block of blocks) {
        if (block.length === 0) continue;
        // Convert the invisible block back to a binary string.
        const binaryStr = [...block]
          .map((ch) => {
            if (ch === ZERO_WIDTH_SPACE) return "0";
            else if (ch === ZERO_WIDTH_NON_JOINER) return "1";
            else {
              console.error("Unexpected character encountered during decoding.");
              return "";
            }
          })
          .join("");
        const codePoint = parseInt(binaryStr, 2);
        decodedText += String.fromCodePoint(codePoint);
      }
      return decodedText;
    }
    
    // Set up DOM event listeners when the document is ready.
    document.addEventListener("DOMContentLoaded", () => {
      const encodeBtn = document.getElementById("encodeBtn");
      const decodeBtn = document.getElementById("decodeBtn");
    
      encodeBtn.addEventListener("click", () => {
        const inputText = document.getElementById("inputText").value;
        const encoded = encodeText(inputText);
        document.getElementById("encodedEmoji").textContent = encoded;
      });
    
      decodeBtn.addEventListener("click", () => {
        const encodedInput = document.getElementById("encodedInput").value;
        const decoded = decodeText(encodedInput);
        document.getElementById("decodedText").textContent = decoded;
      });
    });
  </script>
</body>
</html>
